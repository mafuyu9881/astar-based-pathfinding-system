@Logic
script Pathfinding extends Logic
	property number sqrt2 = math.sqrt(2)

	property table adjOffsets = {}

	method void OnBeginPlay()
		local sqrt2 = self.sqrt2

		self.adjOffsets = {
			{ row = -1, col =  0, weight = 1.0 },
			{ row =  1, col =  0, weight = 1.0 },
			{ row =  0, col = -1, weight = 1.0 },
			{ row =  0, col =  1, weight = 1.0 },
			{ row = -1, col = -1, weight = sqrt2 },
			{ row = -1, col =  1, weight = sqrt2 },
			{ row =  1, col = -1, weight = sqrt2 },
			{ row =  1, col =  1, weight = sqrt2 },
		}
	end

	method table ComputePath(Vector3 departureWorldPosition, Vector3 arrivalWorldPosition, number cellWorldSize, table grid, integer gridHeight, integer gridWidth)
		local waypointWorldPositions = nil
		local arrivalRow, arrivalCol = self:ConvertWorldToIndex2D(arrivalWorldPosition, cellWorldSize, gridHeight, gridWidth)
		if self:Walkable(arrivalRow, arrivalCol, grid, gridHeight, gridWidth) then
			local departureRow, departureCol = self:ConvertWorldToIndex2D(departureWorldPosition, cellWorldSize, gridHeight, gridWidth)
			if departureRow == arrivalRow and departureCol == arrivalCol then
				waypointWorldPositions = {
					departureWorldPosition,
					arrivalWorldPosition
				}
			else
				local adjOffsets = self.adjOffsets

				local departureIndex = self:ConvertIndex2DTo1D(departureRow, departureCol, gridWidth)
				local arrivalIndex = self:ConvertIndex2DTo1D(arrivalRow, arrivalCol, gridWidth)
				local cellCount = gridHeight * gridWidth

				local gScores = {}
				gScores[departureIndex] = 0

				local frontier = _PriorityQueue:New()
				_PriorityQueue:Enqueue(frontier, departureIndex, gScores[departureIndex] + self:ComputeOctileDistance(departureRow, departureCol, arrivalRow, arrivalCol))

				local parentIndices = {}

				while not _PriorityQueue:Empty(frontier) do
					local currIndex, _ = _PriorityQueue:Dequeue(frontier)

					if currIndex == arrivalIndex then
						local waypointIndices = {}
						while currIndex ~= nil do
							table.insert(waypointIndices, 1, currIndex)
							currIndex = parentIndices[currIndex]
						end

						local portals = {}
						for i = 1, #waypointIndices - 1 do
							local srcWaypointIndex = waypointIndices[i]
							local srcWaypointRow, srcWaypointCol = self:ConvertIndex1DTo2D(srcWaypointIndex, gridWidth)

							local dstWaypointIndex = waypointIndices[i + 1]
							local dstWaypointRow, dstWaypointCol = self:ConvertIndex1DTo2D(dstWaypointIndex, gridWidth)

							local portal = self:ComputePortal(
								srcWaypointRow,
								srcWaypointCol,
								dstWaypointRow,
								dstWaypointCol,
								cellWorldSize,
								gridHeight,
								gridWidth
							)
							if portal == nil then
								continue
							end

							-- todo: 디버깅용 시각화 코드, 사용 후 제거
							_Debug:DrawLine(
								_EntityService:GetEntityByPath("/maps/main"),
								portal.leftWP:ToVector2(),
								portal.rightWP:ToVector2(),
								0.025,
								Color(1, 0.5, 0),
								0.05
							)

							table.insert(portals, portal)
						end
						table.insert(portals, { leftWP = arrivalWorldPosition, rightWP = arrivalWorldPosition })

						local tolerance = 0.001

						waypointWorldPositions = {}
						table.insert(waypointWorldPositions, departureWorldPosition)

						local firstPortal = portals[1]
						local funnelApexWP = departureWorldPosition
						local funnelLeftWP = firstPortal.leftWP
						local funnelRightWP = firstPortal.rightWP
						local funnelApexIndex = 0
						local funnelLeftIndex = 1
						local funnelRightIndex = 1

						local i = 1
						while i <= #portals do
							local portal = portals[i]
							local portalLeftWP = portal.leftWP
							local portalRightWP = portal.rightWP

							if self:ComputeParallellogramArea(funnelApexWP, funnelRightWP, portalRightWP) <= 0 then
								if self:NearlyEqual(funnelApexWP, funnelRightWP, tolerance) or (self:ComputeParallellogramArea(funnelApexWP, funnelLeftWP, portalRightWP) > 0) then
									funnelRightWP = portalRightWP
									funnelRightIndex = i
								else
									local newFunnelApexWP = funnelLeftWP
									local newFunnelApexIndex = funnelLeftIndex

									table.insert(waypointWorldPositions, newFunnelApexWP)
									
									funnelApexWP = newFunnelApexWP
									funnelApexIndex = newFunnelApexIndex
									funnelLeftWP = newFunnelApexWP
									funnelLeftIndex = newFunnelApexIndex
									funnelRightWP = newFunnelApexWP
									funnelRightIndex = newFunnelApexIndex

									i = newFunnelApexIndex + 1
									
									continue
								end
							end

							if self:ComputeParallellogramArea(funnelApexWP, funnelLeftWP, portalLeftWP) >= 0 then
								if self:NearlyEqual(funnelApexWP, funnelLeftWP, tolerance) or (self:ComputeParallellogramArea(funnelApexWP, funnelRightWP, portalLeftWP) < 0) then
									funnelLeftWP = portalLeftWP
									funnelLeftIndex = i
								else
									local newFunnelApexWP = funnelRightWP
									local newFunnelApexIndex = funnelRightIndex

									table.insert(waypointWorldPositions, newFunnelApexWP)

									funnelApexWP = newFunnelApexWP
									funnelApexIndex = newFunnelApexIndex
									funnelLeftWP = newFunnelApexWP
									funnelLeftIndex = newFunnelApexIndex
									funnelRightWP = newFunnelApexWP
									funnelRightIndex = newFunnelApexIndex

									i = newFunnelApexIndex + 1

									continue
								end
							end

							i += 1
						end

						table.insert(waypointWorldPositions, arrivalWorldPosition)

						break
					else
						local currRow, currCol = self:ConvertIndex1DTo2D(currIndex, gridWidth)

						for _, adjOffset in ipairs(adjOffsets) do
							local adjRow = currRow + adjOffset.row
							local adjCol = currCol + adjOffset.col
							if self:AdjacencyValidation(currRow, currCol, adjRow, adjCol, grid, gridHeight, gridWidth) == false then
								continue
							end

							local adjIndex = self:ConvertIndex2DTo1D(adjRow, adjCol, gridWidth)
							local currGScore = gScores[currIndex]
							local oldAdjGScore = gScores[adjIndex]
							local newAdjGScore = currGScore + adjOffset.weight
							if oldAdjGScore and newAdjGScore >= oldAdjGScore then
								continue
							end
							
							parentIndices[adjIndex] = currIndex
							gScores[adjIndex] = newAdjGScore
							_PriorityQueue:Enqueue(frontier, adjIndex, newAdjGScore + self:ComputeOctileDistance(adjRow, adjCol, arrivalRow, arrivalCol))
						end
					end
				end
			end
		end
		return waypointWorldPositions
	end
	method number ComputeOctileDistance(integer row1, integer col1, integer row2, integer col2)
		local dx = math.abs(col2 - col1)
		local dy = math.abs(row2 - row1)
		local min = math.min(dx, dy)
		local max = math.max(dx, dy)
		return max + (self.sqrt2 - 1) * min
	end
	method boolean AdjacencyValidation(integer srcRow, integer srcCol, integer dstRow, integer dstCol, table grid, integer gridHeight, integer gridWidth)
		if not self:InBounds(dstRow, dstCol, gridHeight, gridWidth) then
			return false
		end

		if not self:Walkable(dstRow, dstCol, grid, gridHeight, gridWidth) then
			return false
		end

		local deltaRow = dstRow - srcRow
		local deltaCol = dstCol - srcCol

		if deltaRow ~= 0 and deltaCol ~= 0 then
			if not self:InBounds(srcRow, srcCol + deltaCol, gridHeight, gridWidth) then
				return false
			end

			if not self:Walkable(srcRow, srcCol + deltaCol, grid, gridHeight, gridWidth) then
				return false
			end

			if not self:InBounds(srcRow + deltaRow, srcCol, gridHeight, gridWidth) then
				return false
			end

			if not self:Walkable(srcRow + deltaRow, srcCol, grid, gridHeight, gridWidth) then
				return false
			end
		end
		
		return true
	end
	method boolean Walkable(integer row, integer col, table grid, integer gridHeight, integer gridWidth)
		if grid == nil then
			return true
		end

		if not self:InBounds(row, col, gridHeight, gridWidth) then
			return false
		end
		
		local index = self:ConvertIndex2DTo1D(row, col, gridWidth)
		if grid[index] < 1 then
			return false
		end

		return true
	end
	method table ComputePortal(integer srcRow, integer srcCol, integer dstRow, integer dstCol, number cellWorldSize, integer gridHeight, integer gridWidth)
		local srcWP = self:ConvertIndex2DToWorld(srcRow, srcCol, cellWorldSize, gridHeight, gridWidth)
		local dstWP = self:ConvertIndex2DToWorld(dstRow, dstCol, cellWorldSize, gridHeight, gridWidth)
		local midpointWP = (srcWP + dstWP) * 0.5

		local portal = nil

		if srcRow == dstRow then
			if srcCol < dstCol then
				portal = {
					leftWP = midpointWP + Vector3(0, 1, 0) * cellWorldSize * 0.5,
					rightWP = midpointWP + Vector3(0, -1, 0) * cellWorldSize * 0.5
				}
			elseif srcCol > dstCol then
				portal = {
					leftWP = midpointWP + Vector3(0, -1, 0) * cellWorldSize * 0.5,
					rightWP = midpointWP + Vector3(0, 1, 0) * cellWorldSize * 0.5
				}
			end
		elseif srcCol == dstCol then
			if srcRow < dstRow then
				portal = {
					leftWP = midpointWP + Vector3(-1, 0, 0) * cellWorldSize * 0.5,
					rightWP = midpointWP + Vector3(1, 0, 0) * cellWorldSize * 0.5
				}
			elseif srcRow > dstRow then
				portal = {
					leftWP = midpointWP + Vector3(1, 0, 0) * cellWorldSize * 0.5,
					rightWP = midpointWP + Vector3(-1, 0, 0) * cellWorldSize * 0.5
				}
			end
		else
			if srcRow < dstRow and srcCol < dstCol then
				portal = {
					leftWP = midpointWP + Vector3(-1, 1, 0) * cellWorldSize,
					rightWP = midpointWP + Vector3(1, -1, 0) * cellWorldSize
				}
			elseif srcRow > dstRow and srcCol < dstCol then
				portal = {
					leftWP = midpointWP + Vector3(1, 1, 0) * cellWorldSize,
					rightWP = midpointWP + Vector3(-1, -1, 0) * cellWorldSize
				}
			elseif srcRow > dstRow and srcCol > dstCol then
				portal = {
					leftWP = midpointWP + Vector3(1, -1, 0) * cellWorldSize,
					rightWP = midpointWP + Vector3(-1, 1, 0) * cellWorldSize
				}
			elseif srcRow < dstRow and srcCol > dstCol then
				portal = {
					leftWP = midpointWP + Vector3(-1, -1, 0) * cellWorldSize,
					rightWP = midpointWP + Vector3(1, 1, 0) * cellWorldSize
				}
			end
		end

		return portal
	end
	method number ComputeParallellogramArea(Vector3 p, Vector3 v0, Vector3 v1)
		local pToV0 = v0 - p
		local pToV1 = v1 - p
		return pToV1.x * pToV0.y - pToV0.x * pToV1.y
	end
	method boolean NearlyEqual(Vector3 a, Vector3 b, number tolerance)
		return math.abs((a:ToVector2() - b:ToVector2()):Magnitude()) <= tolerance
	end

	-- converter

	method any InBounds(integer row, integer col, integer gridHeight, integer gridWidth)
		if row < 1 or row > gridHeight then
			return false
		end

		if col < 1 or col > gridWidth then
			return false
		end

		return true
	end
	method integer ConvertIndex2DTo1D(integer row, integer col, integer gridWidth)
		return (row - 1) * gridWidth + col
	end
	method any ConvertIndex1DTo2D(integer index, integer gridWidth)
		local row = math.floor((index - 1) / gridWidth) + 1
		local col = ((index - 1) % gridWidth) + 1
		return row, col
	end
	method Vector3 ConvertIndex2DToWorld(integer row, integer col, number cellWorldSize, integer gridHeight, integer gridWidth)
		local gridWorldHeight = cellWorldSize * gridHeight
		local gridWorldWidth = cellWorldSize * gridWidth

		local y = (row - 0.5) * cellWorldSize - (gridWorldHeight * 0.5)
		local x = (col - 0.5) * cellWorldSize - (gridWorldWidth * 0.5)

		return Vector3(x, y, 0)
	end
	method any ConvertWorldToIndex2D(Vector3 worldPosition, number cellWorldSize, integer gridHeight, integer gridWidth)
		local gridWorldHeight = cellWorldSize * gridHeight
		local gridWorldWidth = cellWorldSize * gridWidth

		local gridHalfWorldHeight = gridWorldHeight * 0.5
		local gridHalfWorldWidth = gridWorldWidth * 0.5

		local row = math.floor((worldPosition.y + gridWorldHeight * 0.5) / cellWorldSize)
		local col = math.floor((worldPosition.x + gridWorldWidth * 0.5) / cellWorldSize)

		-- 0 기반 인덱스에서 1 기반 인덱스로 변환
		row += 1
		col += 1

		return row, col
	end
end